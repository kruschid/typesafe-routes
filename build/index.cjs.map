{"mappings":"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","sources":["src/index.ts","src/param.ts","src/routes.ts","src/createRoutes.ts","src/renderer.ts"],"sourcesContent":["export * from \"./param\";\nexport * from \"./routes\";\nexport * from \"./createRoutes\";\nexport * from \"./renderer\";\n","export type ParamKind = \"optional\" | \"required\";\n\nexport type AnyParam = Param<string, any, any>;\n\nexport type Param<N = string, T = any, K extends ParamKind = \"required\"> = {\n  name: N;\n  kind: K;\n  parser: Parser<T>;\n} & (K extends \"required\" ? { optional: Param<N, T, \"optional\"> } : {});\n\nexport interface Parser<T> {\n  parse: (value: string) => T;\n  serialize: (value: T) => string;\n}\n\ntype ParamFn = <T>(\n  parser: Parser<T>\n) => <N extends string>(name: N) => Param<N, T, \"required\">;\n\nexport const param: ParamFn = (parser) => (name) => ({\n  name,\n  kind: \"required\",\n  parser,\n  optional: {\n    name,\n    kind: \"optional\",\n    parser,\n  } as Param<any, any, \"optional\">,\n});\n\nexport const int = param({\n  parse: (value: string) => {\n    const result = parseInt(value, 10);\n    if (result !== result) {\n      throw new Error(`parameter value is invalid: \"${result}\"`);\n    }\n    return result;\n  },\n  serialize: (value: number) => value.toString(),\n});\n\nexport const str = param({\n  parse: (value: string) => value,\n  serialize: (value: string) => value,\n});\n\nexport const float = (fractionDigits?: number) =>\n  param({\n    parse: (value: string) => parseFloat(value),\n    serialize: (value: number) => value.toFixed(fractionDigits),\n  });\n\nexport const isoDate = param({\n  parse: (value: string) => new Date(value),\n  serialize: (value: Date) => value.toISOString(),\n});\n\nexport const date = param({\n  parse: (value: string) => new Date(value),\n  serialize: (value: Date) => value.toISOString().slice(0, 10),\n});\n\nexport const bool = param({\n  parse: (value: string) => value === \"true\",\n  serialize: (value: boolean) => value.toString(),\n});\n\nexport const oneOf = (...list: string[]) =>\n  param({\n    parse: (value: string) => {\n      if (!list.includes(value)) {\n        throw new Error(`\"${value}\" is none of ${list.join(\",\")}`);\n      }\n      return value;\n    },\n    serialize: (value: string) => value,\n  });\n\nexport const list = (_: string[], separator = \";\") =>\n  param({\n    parse: (value: string) => value.split(separator),\n    serialize: (options: string[]) => options.join(separator),\n  });\n\nexport const json = <T>() =>\n  param({\n    parse: (value: string) => JSON.parse(value),\n    serialize: (value: T) => JSON.stringify(value),\n  });\n\nexport const base64 = <T>() =>\n  param({\n    parse: (value) => JSON.parse(window.btoa(value)),\n    serialize: (value: T) => window.atob(JSON.stringify(value)),\n  });\n","import type { A } from \"ts-toolbelt\";\nimport { RenderContext } from \"./createRoutes\";\nimport type { AnyParam } from \"./param\";\nimport type { Renderer } from \"./renderer\";\n\ntype If<Condition, Then> = Condition extends true ? Then : never;\ntype Unwrap<T> = T extends unknown[] ? T[number] : never;\n\n/**\n * ExcludeEmptyProperties<{\n *  path: {param: string},\n *  query: {}\n * }> => {\n *  path: {param: string},\n *  query: never,\n * }\n */\ntype ExcludeEmptyProperties<T> = Pick<\n  T,\n  {\n    [K in keyof T]: keyof T[K] extends never ? never : K;\n  }[keyof T]\n>;\n\nexport type RouteNode = {\n  path?: (string | AnyParam)[];\n  template?: string;\n  query?: AnyParam[];\n  children?: RouteNodeMap;\n};\nexport type RouteNodeMap = Record<string, RouteNode>;\n\n/**\n * RouteNodeToParamRecordMap<{\n *  path?: (string | AnyParamParam<TName, TValue>)[];\n *  query?: Param<TName, TValue>[];\n *  children?: RouteNodeMap;\n * }> => {\n *  path: {[TName]: TValue, ...},\n *  query: {[TName]: TValue, ...}\n * }\n */\nexport type RouteNodeToParamRecordMap<T extends RouteNode> = {\n  path: ExtractParamRecord<Exclude<Unwrap<T[\"path\"]>, string | undefined>>;\n  query: ExtractParamRecord<Exclude<Unwrap<T[\"query\"]>, undefined>>;\n};\nexport type ParamRecordMap<T = unknown> = Record<\"path\" | \"query\", T>;\n\n/**\n * ExtractParamRecord<{\n *  kind: \"required\" | \"optional\";\n *  name: TName;\n *  parser: Parser<TParseType>\n * } | {...}> => {\n *  [TName]: TParseType,\n *  [TName]?: TParseType,\n *  ...\n * }\n */\nexport type ExtractParamRecord<Params extends AnyParam> = {\n  [K in Extract<Params, { kind: \"required\" }>[\"name\"]]: ReturnType<\n    Extract<Params, { name: K }>[\"parser\"][\"parse\"]\n  >;\n} & {\n  [K in Extract<Params, { kind: \"optional\" }>[\"name\"]]?: ReturnType<\n    Extract<Params, { name: K }>[\"parser\"][\"parse\"]\n  >;\n};\n\n/**\n * ExtractPathSuggestions<{\n *  childA: {\n *    ...,\n *    childrend: {\n *      childB: {\n *        ...\n *      }\n *    }\n *  }\n * }> =>\n *  | \"childA\"\n *  | \"childA/childB\"\n *  | \"childA/_childB\"\n */\nexport type ExtractPathSuggestions<\n  T extends RouteNodeMap,\n  IsTemplate = false,\n  IsAbsolute = true\n> = {\n  // K = NodeName\n  [K in keyof T]: K extends string // filters out symbol and number\n    ? T[K][\"children\"] extends object // has children\n      ?\n          | K\n          | `${K}/${ExtractPathSuggestions<T[K][\"children\"], IsTemplate>}`\n          | If<\n              IsAbsolute,\n              `${K}/_${ExtractPathSuggestions<\n                T[K][\"children\"],\n                IsTemplate,\n                false\n              >}`\n            >\n      : T[K][\"template\"] extends string\n      ? If<IsTemplate, K>\n      : K\n    : never;\n}[keyof T];\n\n/**\n * PathToParamRecordMap<\n *  \"segement/segment/segment\",\n *  {segment: {..., children: {segment: {..., children: {segment}}}}},\n *  {path: {...}, query: {...}}\n * > => { param: type, ...}\n */\nexport type PathToParamRecordMap<\n  Path extends string,\n  Route extends RouteNodeMap,\n  Params extends ParamRecordMap = ParamRecordMap\n> = Path extends `_${infer Segment}/${infer Rest}` // partial route segment (drop all previous options)\n  ? PathToParamRecordMap<\n      Rest,\n      Route[Segment][\"children\"] & {}, // shortcut to exclude undefined\n      RouteNodeToParamRecordMap<Route[Segment]>\n    >\n  : Path extends `${infer Segment}/${infer Rest}` // regular segment (concat options)\n  ? PathToParamRecordMap<\n      Rest,\n      Route[Segment][\"children\"] & {}, // shortcut to exclude undefined\n      Params & RouteNodeToParamRecordMap<Route[Segment]>\n    >\n  : Path extends `_${infer Segment}` // partial route in the final segment (drop previous options and discontinue)\n  ? RouteNodeToParamRecordMap<Route[Segment]>\n  : Params & RouteNodeToParamRecordMap<Route[Path]>;\n\n/**\n * ExtractRouteNodeMapByPath<\n *  \"segement/segment\",\n *  {segment: {..., children: {segment: {..., children: {segment: { ... }}}}}},\n * > => {segment: { ... }},\n */\nexport type ExtractRouteNodeMapByPath<\n  Path extends string,\n  Route extends RouteNodeMap\n> = Path extends `_${infer Segment}/${infer Rest}` // partial route segment (drop all previous options)\n  ? ExtractRouteNodeMapByPath<\n      Rest,\n      Route[Segment][\"children\"] & {} // shortcut to exclude undefined\n    >\n  : Path extends `${infer Segment}/${infer Rest}` // regular segment (concat options)\n  ? ExtractRouteNodeMapByPath<\n      Rest,\n      Route[Segment][\"children\"] & {} // shortcut to exclude undefined\n    >\n  : Path extends `_${infer Segment}` // partial route in the final segment (drop previous options and discontinue)\n  ? Route[Segment][\"children\"] & {}\n  : Route[Path][\"children\"] & {};\n\nexport type RoutesContext<Routes extends RouteNodeMap> = {\n  template: (path: ExtractPathSuggestions<Routes, true>) => string;\n  render: <Path extends ExtractPathSuggestions<Routes>>(\n    ...args:\n      | [\n          path: Path,\n          params: A.Compute<\n            ExcludeEmptyProperties<PathToParamRecordMap<Path, Routes>>\n          >\n        ]\n      | []\n  ) => string;\n  parseParams: <Path extends ExtractPathSuggestions<Routes>>(\n    path: Path,\n    params: Record<string, any>\n  ) => PathToParamRecordMap<Path, Routes>[\"path\"];\n  parseQuery: <Path extends ExtractPathSuggestions<Routes>>(\n    path: Path,\n    params: Record<string, any>\n  ) => PathToParamRecordMap<Path, Routes>[\"query\"];\n  bind: <Path extends ExtractPathSuggestions<Routes>>(\n    path: Path,\n    params: A.Compute<\n      ExcludeEmptyProperties<PathToParamRecordMap<Path, Routes>>\n    >\n  ) => RoutesContext<ExtractRouteNodeMapByPath<Path, Routes>>;\n  from: <Path extends ExtractPathSuggestions<Routes>>(\n    path: Path,\n    location: string,\n    params?: A.Compute<\n      ExcludeEmptyProperties<{\n        path: Partial<PathToParamRecordMap<Path, Routes>[\"path\"]>;\n        query: Partial<PathToParamRecordMap<Path, Routes>[\"query\"]>;\n      }>\n    >\n  ) => RoutesContext<ExtractRouteNodeMapByPath<Path, Routes>>;\n  replace: <Path extends ExtractPathSuggestions<Routes>>(\n    path: Path,\n    location: string,\n    params: A.Compute<\n      ExcludeEmptyProperties<{\n        path: Partial<PathToParamRecordMap<Path, Routes>[\"path\"]>;\n        query: Partial<PathToParamRecordMap<Path, Routes>[\"query\"]>;\n      }>\n    >\n  ) => string;\n};\n\nexport type CreateRoutes = <Routes extends RouteNodeMap>(\n  routes: Routes,\n  renderer?: Renderer,\n  parentContext?: RenderContext\n) => RoutesContext<Routes>;\n","import {\n  CreateRoutes,\n  ParamRecordMap,\n  RouteNode,\n  RouteNodeMap,\n  RoutesContext,\n  defaultRenderer,\n  str,\n} from \".\";\n\nexport type RenderContext = {\n  skippedNodes: RouteNode[]; // containes leading nodes that were skipped in a relative path\n  nodes: RouteNode[];\n  pathSegments: Exclude<RouteNode[\"path\"], undefined>;\n  querySegments: Exclude<RouteNode[\"query\"], undefined>;\n  currentPathSegments: Exclude<RouteNode[\"path\"], undefined>;\n  currentQuerySegments: Exclude<RouteNode[\"query\"], undefined>;\n  isRelative: boolean;\n  pathParams: Record<string, string>;\n  queryParams: Record<string, string>;\n};\n\nexport const createRoutes: CreateRoutes = (\n  routeMap,\n  renderer = defaultRenderer,\n  parentContext\n) => {\n  const render = (\n    path?: string,\n    params?: ParamRecordMap<any>,\n    context?: RenderContext\n  ) => {\n    const ctx = pipe(\n      context ?? createRenderContext(routeMap, path, parentContext),\n      addPathParams(params?.path),\n      addQueryParams(params?.query)\n    );\n\n    return renderer.render(ctx);\n  };\n\n  const bind = (path: string, params: ParamRecordMap<any>) => {\n    const ctx = pipe(\n      createRenderContext(routeMap, path, parentContext),\n      addPathParams(params.path),\n      addQueryParams(params.query)\n    );\n\n    const pathChildren = ctx.nodes[ctx.nodes.length - 1].children ?? {};\n\n    return createRoutes(pathChildren, renderer, ctx);\n  };\n\n  const template = (path: string) =>\n    renderer.template(createRenderContext(routeMap, path));\n\n  const parseParams = (\n    path: string,\n    paramsOrLocation: Record<string, string> | string\n  ) =>\n    parsePathParams(\n      pipe(\n        createRenderContext(routeMap, path, parentContext),\n        typeof paramsOrLocation === \"string\"\n          ? addPathParamsFromLocationPath(paramsOrLocation)\n          : addRawPathParams(paramsOrLocation)\n      )\n    );\n\n  const parseQuery = (path: string, query: Record<string, string> | string) =>\n    parseQueryParams(\n      pipe(\n        createRenderContext(routeMap, path, parentContext),\n        typeof query === \"string\"\n          ? addQueryParamsFromUrlSearch(query)\n          : addRawQueryParams(query)\n      )\n    );\n\n  const from = (\n    path: string,\n    location: string,\n    params?: ParamRecordMap<Record<string, unknown>>\n  ) => {\n    const [locationPath, locationQuery] = location.split(\"?\");\n    const ctx = pipe(\n      createRenderContext(routeMap, path, parentContext),\n      addPathParamsFromLocationPath(locationPath),\n      addQueryParamsFromUrlSearch(locationQuery),\n      overrideParams(params)\n    );\n\n    const pathChildren = ctx.nodes[ctx.nodes.length - 1].children ?? {};\n\n    return createRoutes(pathChildren, renderer, ctx);\n  };\n\n  // basically the same as the from method but returns rendered path with remaining segments appended\n  // appends query string as well (if available)\n  const replace = (\n    path: string,\n    location: string,\n    params: ParamRecordMap<Record<string, unknown>>\n  ) => {\n    const [locationPath, locationQuery] = location.split(\"?\");\n    const ctx = pipe(\n      createRenderContext(routeMap, path, parentContext),\n      addPathParamsFromLocationPath(locationPath, true),\n      addQueryParamsFromUrlSearch(locationQuery, true),\n      overrideParams(params)\n    );\n\n    return renderer.render(ctx);\n  };\n\n  return {\n    render,\n    bind,\n    template,\n    parseParams,\n    parseQuery,\n    from,\n    replace,\n  } as RoutesContext<any>;\n};\n\nconst createRenderContext = (\n  routeMap: RouteNodeMap,\n  path?: string,\n  parentCtx?: RenderContext\n): RenderContext => {\n  let ctx: RenderContext = parentCtx ?? {\n    skippedNodes: [],\n    nodes: [],\n    pathSegments: [],\n    querySegments: [],\n    isRelative: false,\n    currentPathSegments: [],\n    currentQuerySegments: [],\n    pathParams: {},\n    queryParams: {},\n  };\n\n  if (!path) {\n    return ctx;\n  }\n\n  const [absolutePath, relativePath] = path.split(\"/_\");\n  const isRelative = typeof relativePath === \"string\";\n\n  if (isRelative) {\n    ctx = {\n      ...ctx,\n      skippedNodes: ctx.skippedNodes.concat(ctx.nodes),\n      nodes: [],\n      pathSegments: [],\n      querySegments: [],\n      isRelative: true,\n    };\n  }\n\n  let nextNodeMap: RouteNodeMap | undefined = routeMap;\n\n  // skip leading segments in relative path\n  if (isRelative) {\n    absolutePath.split(\"/\").forEach((nodeName) => {\n      if (!nextNodeMap?.[nodeName]) {\n        throw Error(`unknown path segment \"${nodeName}\" in ${path}`);\n      }\n      ctx = {\n        ...ctx,\n        skippedNodes: ctx.skippedNodes.concat(nextNodeMap[nodeName]),\n      };\n      nextNodeMap = nextNodeMap[nodeName].children;\n    });\n  }\n\n  // resets current segments\n  ctx = {\n    ...ctx,\n    currentPathSegments: [],\n    currentQuerySegments: [],\n  };\n\n  (relativePath ?? absolutePath).split(\"/\").forEach((nodeName, i) => {\n    if (!nextNodeMap) {\n      throw Error(`unknown segment ${nodeName}`);\n    }\n\n    const nextNode = nextNodeMap[nodeName];\n    ctx = {\n      ...ctx,\n      nodes: ctx.nodes.concat(nextNode),\n      pathSegments: ctx.pathSegments.concat(\n        nextNode.path ?? (nextNode.template ? [nextNode.template] : [])\n      ),\n      querySegments: ctx.querySegments.concat(nextNode.query ?? []),\n      currentPathSegments: ctx.currentPathSegments.concat(nextNode.path ?? []),\n      currentQuerySegments: ctx.currentQuerySegments.concat(\n        nextNode.query ?? []\n      ),\n    };\n    nextNodeMap = nextNode.children;\n  });\n\n  return ctx;\n};\n\nconst addPathParamsFromLocationPath =\n  (locationPath: string = \"\", includeExtraPath: boolean = false) =>\n  (ctx: RenderContext): RenderContext => {\n    const remaining = locationPath\n      .slice(locationPath[0] === \"/\" ? 1 : 0)\n      .split(\"/\");\n\n    const pathParams: Record<string, string> = {};\n\n    // keep track of recent optional params since they might contain path segments\n    // if a path segment doesn't match the algorithm continues searching in this array\n    const recentOptionalParams: string[] = [];\n\n    ctx.currentPathSegments.forEach((segment) => {\n      const locationPathSegment = remaining.shift();\n\n      if (typeof segment === \"string\") {\n        if (segment === locationPathSegment) {\n          recentOptionalParams.length = 0; // irrelevant from here\n        } else {\n          // segment might have been swallowed by an optional param\n          let recentParam: string | undefined;\n          let foundMatch = false;\n          while ((recentParam = recentOptionalParams.shift())) {\n            if (pathParams[recentParam] === segment) {\n              delete pathParams[recentParam];\n              // hold segment back for the next iteration\n              locationPathSegment && remaining.unshift(locationPathSegment);\n              foundMatch = true;\n            }\n          }\n          if (!foundMatch) {\n            throw new Error(\n              `\"${locationPath}\" doesn't match \"${defaultRenderer.template(\n                ctx\n              )}\", missing segment \"${segment}\"`\n            );\n          }\n        }\n      } else {\n        if (locationPathSegment != null) {\n          pathParams[segment.name] = locationPathSegment;\n          if (segment.kind === \"optional\") {\n            recentOptionalParams.push(segment.name);\n          } else {\n            recentOptionalParams.length = 0;\n          }\n        } else if (segment.kind === \"required\") {\n          throw new Error(\n            `\"${locationPath}\" doesn't match \"${defaultRenderer.template(\n              ctx\n            )}\", missing parameter \"${segment.name}\"`\n          );\n        }\n      }\n    });\n\n    return {\n      ...ctx,\n      pathParams: { ...ctx.pathParams, ...pathParams },\n      pathSegments: includeExtraPath\n        ? ctx.pathSegments.concat(remaining)\n        : ctx.pathSegments,\n    };\n  };\n\nconst addPathParams =\n  (params?: Record<string, unknown>) =>\n  (ctx: RenderContext): RenderContext => {\n    if (!params) return ctx;\n\n    const pathParams: Record<string, string> = {};\n\n    ctx.currentPathSegments.forEach((segment) => {\n      if (typeof segment === \"string\") {\n        return;\n      }\n      if (params[segment.name] != null) {\n        pathParams[segment.name] = segment.parser.serialize(\n          params[segment.name]\n        );\n      } else if (segment.kind === \"required\") {\n        throw Error(\n          `required path parameter \"${\n            segment.name\n          }\" was not provided in \"${defaultRenderer.template(ctx)}\"`\n        );\n      }\n    });\n\n    return {\n      ...ctx,\n      pathParams: { ...ctx.pathParams, ...pathParams },\n    };\n  };\n\nconst addRawPathParams =\n  (params?: Record<string, string>) =>\n  (ctx: RenderContext): RenderContext => ({\n    ...ctx,\n    pathParams: { ...ctx.pathParams, ...params },\n  });\n\nconst parsePathParams = (ctx: RenderContext): Record<string, unknown> => {\n  const parsedParams: Record<string, any> = {};\n\n  ctx.pathSegments.forEach((segment) => {\n    if (typeof segment === \"string\") {\n      return;\n    }\n    const value = ctx.pathParams[segment.name];\n    if (value != null) {\n      parsedParams[segment.name] = segment.parser.parse(value);\n    } else if (segment.kind === \"required\") {\n      throw Error(\n        `parsePathParams: required path parameter \"${\n          segment.name\n        }\" was not provided in \"${defaultRenderer.template(ctx)}\"`\n      );\n    }\n  });\n\n  return parsedParams;\n};\n\nconst addQueryParamsFromUrlSearch =\n  (urlSearchParams: string = \"\", includeExtraQuery: boolean = false) =>\n  (ctx: RenderContext): RenderContext => ({\n    ...ctx,\n    ...addQueryParams(\n      Object.fromEntries(new URLSearchParams(urlSearchParams)),\n      includeExtraQuery\n    )(ctx),\n  });\n\nconst addQueryParams =\n  (source?: Record<string, unknown>, includeExtraQuery: boolean = false) =>\n  (ctx: RenderContext): RenderContext => {\n    const remaining = { ...source };\n    const queryParams: Record<string, string> = {};\n\n    ctx.currentQuerySegments.forEach(({ name, parser, kind }) => {\n      if (remaining[name] != null) {\n        queryParams[name] = parser.serialize(remaining[name]);\n        delete remaining[name];\n      } else if (kind === \"required\") {\n        throw Error(\n          `parsePathParams: required path parameter \"${name}\" was not provided in \"${defaultRenderer.template(\n            ctx\n          )}\"`\n        );\n      }\n    });\n\n    return {\n      ...ctx,\n      queryParams: {\n        ...ctx.queryParams,\n        ...queryParams,\n        ...(includeExtraQuery\n          ? (remaining as Record<string, string>)\n          : undefined),\n      },\n      querySegments: includeExtraQuery\n        ? ctx.querySegments.concat(\n            Object.keys(remaining).map((name) => str(name).optional)\n          )\n        : ctx.querySegments,\n    };\n  };\n\nconst addRawQueryParams =\n  (params?: Record<string, string>) =>\n  (ctx: RenderContext): RenderContext => ({\n    ...ctx,\n    queryParams: { ...ctx.queryParams, ...params },\n  });\n\nconst parseQueryParams = (ctx: RenderContext): Record<string, unknown> => {\n  const parsedQuery: Record<string, any> = {};\n\n  ctx.querySegments.forEach((segment) => {\n    const value = ctx.queryParams[segment.name];\n    if (value != null) {\n      parsedQuery[segment.name] = segment.parser.parse(value);\n    } else if (segment.kind === \"required\") {\n      throw Error(\n        `parseQueryParams: required query parameter \"${\n          segment.name\n        }\" was not provided in \"${defaultRenderer.template(ctx)}\"`\n      );\n    }\n  });\n\n  return parsedQuery;\n};\n\nconst overrideParams =\n  (params?: ParamRecordMap<Record<string, unknown>>) =>\n  (ctx: RenderContext): RenderContext => {\n    const pathParams = { ...ctx.pathParams };\n    if (params?.path) {\n      ctx.currentPathSegments.forEach((segment) => {\n        if (typeof segment !== \"string\" && segment.name in params.path) {\n          if (params.path[segment.name] != null) {\n            pathParams[segment.name] = segment.parser.serialize(\n              params.path[segment.name]\n            );\n          } else if (segment.kind === \"optional\") {\n            delete pathParams[segment.name];\n          } else {\n            throw Error(\n              `overrideParams: required path parameter \"${\n                segment.name\n              }\" can not be removed from \"${defaultRenderer.template(ctx)}\"`\n            );\n          }\n        }\n      });\n    }\n\n    const queryParams = { ...ctx.queryParams };\n    if (params?.query) {\n      ctx.currentQuerySegments.forEach(({ name, kind, parser }) => {\n        if (name in params.query) {\n          if (params.query[name] != null) {\n            queryParams[name] = parser.serialize(params.query[name]);\n          } else if (kind === \"optional\") {\n            delete queryParams[name];\n          } else {\n            throw Error(\n              `overrideParams: required query parameter \"${name}\" can not be removed from \"${defaultRenderer.template(\n                ctx\n              )}\"`\n            );\n          }\n        }\n      });\n    }\n\n    return {\n      ...ctx,\n      pathParams,\n      queryParams,\n    };\n  };\n\nconst pipe = (\n  initialCtx: RenderContext,\n  ...fns: ((ctx: RenderContext) => RenderContext)[]\n) => fns.reduce((ctx, fn) => fn(ctx), initialCtx);\n","import { RenderContext } from \"./createRoutes\";\n\nexport type Renderer = {\n  template: (ctx: RenderContext) => string;\n  render: (ctx: RenderContext) => string;\n};\n\nexport const defaultRenderer: Renderer = {\n  template: ({ pathSegments, isRelative }) => {\n    const template = pathSegments\n      .map((pathSegment) =>\n        typeof pathSegment === \"string\"\n          ? pathSegment\n          : `:${pathSegment.name}${pathSegment.kind === \"optional\" ? \"?\" : \"\"}`\n      )\n      .join(\"/\");\n\n    return isRelative\n      ? template //relative\n      : `/${template}`; // absolute\n  },\n  render: ({ pathSegments, isRelative, pathParams, queryParams }) => {\n    const path: string[] = [];\n    // path params\n    pathSegments.forEach((pathSegment) => {\n      if (typeof pathSegment === \"string\") {\n        path.push(pathSegment);\n      } else if (pathParams[pathSegment.name] != null) {\n        path.push(pathParams[pathSegment.name]);\n      }\n    });\n\n    const searchParams = new URLSearchParams(queryParams).toString();\n\n    return (\n      (isRelative ? \"\" : \"/\") +\n      path.join(\"/\") +\n      (searchParams ? `?` : \"\") +\n      searchParams\n    );\n  },\n};\n"],"names":[],"version":3,"file":"index.cjs.map","sourceRoot":"../"}