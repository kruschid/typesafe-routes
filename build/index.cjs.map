{"mappings":"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","sources":["src/index.ts","src/param.ts","src/routes.ts","src/createRoutes.ts","src/renderer.ts"],"sourcesContent":["export * from \"./param\";\nexport * from \"./routes\";\nexport * from \"./createRoutes\";\nexport * from \"./renderer\";\n","export type ParamKind = \"optional\" | \"required\";\n\nexport type AnyParam = Param<string, any, any>;\n\nexport type Param<N = string, T = any, K extends ParamKind = \"required\"> = {\n  name: N;\n  kind: K;\n  parser: Parser<T>;\n  value?: string;\n} & (K extends \"required\" ? { optional: Param<N, T, \"optional\"> } : {});\n\nexport interface Parser<T> {\n  parse: (value: string) => T;\n  serialize: (value: T) => string;\n}\n\ntype ParamFn = <T>(\n  parser: Parser<T>\n) => <N extends string>(name: N) => Param<N, T, \"required\">;\n\nexport const param: ParamFn = (parser) => (name) => ({\n  name,\n  kind: \"required\",\n  parser,\n  optional: {\n    name,\n    kind: \"optional\",\n    parser,\n  } as Param<any, any, \"optional\">,\n});\n\nexport const int = param({\n  parse: (value: string) => {\n    const result = parseInt(value, 10);\n    if (result !== result) {\n      throw new Error(`parameter value is invalid: \"${result}\"`);\n    }\n    return result;\n  },\n  serialize: (value: number) => value.toString(),\n});\n\nexport const str = param({\n  parse: (value: string) => value,\n  serialize: (value: string) => value,\n});\n\nexport const float = (fractionDigits?: number) =>\n  param({\n    parse: (value: string) => parseFloat(value),\n    serialize: (value: number) => value.toFixed(fractionDigits),\n  });\n\nexport const isoDate = param({\n  parse: (value: string) => new Date(value),\n  serialize: (value: Date) => value.toISOString(),\n});\n\nexport const date = param({\n  parse: (value: string) => new Date(value),\n  serialize: (value: Date) => value.toISOString().slice(0, 10),\n});\n\nexport const bool = param({\n  parse: (value: string) => value === \"true\",\n  serialize: (value: boolean) => value.toString(),\n});\n\nexport const oneOf = (...list: string[]) =>\n  param({\n    parse: (value: string) => {\n      if (!list.includes(value)) {\n        throw new Error(`\"${value}\" is none of ${list.join(\",\")}`);\n      }\n      return value;\n    },\n    serialize: (value: string) => value,\n  });\n\nexport const list = (_: string[], separator = \";\") =>\n  param({\n    parse: (value: string) => value.split(separator),\n    serialize: (options: string[]) => options.join(separator),\n  });\n\nexport const json = <T>() =>\n  param({\n    parse: (value: string) => JSON.parse(value),\n    serialize: (value: T) => JSON.stringify(value),\n  });\n\nexport const base64 = <T>() =>\n  param({\n    parse: (value) => JSON.parse(window.btoa(value)),\n    serialize: (value: T) => window.atob(JSON.stringify(value)),\n  });\n","import type { A } from \"ts-toolbelt\";\nimport type { AnyParam } from \"./param\";\nimport type { RenderContext, Renderer } from \"./renderer\";\n\ntype If<Condition, Then> = Condition extends true ? Then : never;\ntype Unwrap<T> = T extends unknown[] ? T[number] : never;\n\n/**\n * ExcludeEmptyProperties<{\n *  path: {param: string},\n *  query: {}\n * }> => {\n *  path: {param: string},\n *  query: never,\n * }\n */\ntype ExcludeEmptyProperties<T> = Pick<\n  T,\n  {\n    [K in keyof T]: keyof T[K] extends never ? never : K;\n  }[keyof T]\n>;\n\nexport type RouteNode = {\n  path?: (string | AnyParam)[];\n  template?: string;\n  query?: AnyParam[];\n  children?: RouteNodeMap;\n};\nexport type RouteNodeMap = Record<string, RouteNode>;\n\n/**\n * RouteNodeToParamRecordMap<{\n *  path?: (string | AnyParamParam<TName, TValue>)[];\n *  query?: Param<TName, TValue>[];\n *  children?: RouteNodeMap;\n * }> => {\n *  path: {[TName]: TValue, ...},\n *  query: {[TName]: TValue, ...}\n * }\n */\nexport type RouteNodeToParamRecordMap<T extends RouteNode> = {\n  path: ExtractParamRecord<Exclude<Unwrap<T[\"path\"]>, string | undefined>>;\n  query: ExtractParamRecord<Exclude<Unwrap<T[\"query\"]>, undefined>>;\n};\nexport type ParamRecordMap<T = unknown> = Record<\"path\" | \"query\", T>;\n\n/**\n * ExtractParamRecord<{\n *  kind: \"required\" | \"optional\";\n *  name: TName;\n *  parser: Parser<TParseType>\n * } | {...}> => {\n *  [TName]: TParseType,\n *  [TName]?: TParseType,\n *  ...\n * }\n */\nexport type ExtractParamRecord<Params extends AnyParam> = {\n  [K in Extract<Params, { kind: \"required\" }>[\"name\"]]: ReturnType<\n    Extract<Params, { name: K }>[\"parser\"][\"parse\"]\n  >;\n} & {\n  [K in Extract<Params, { kind: \"optional\" }>[\"name\"]]?: ReturnType<\n    Extract<Params, { name: K }>[\"parser\"][\"parse\"]\n  >;\n};\n\n/**\n * ExtractPathSuggestions<{\n *  childA: {\n *    ...,\n *    childrend: {\n *      childB: {\n *        ...\n *      }\n *    }\n *  }\n * }> =>\n *  | \"childA\"\n *  | \"childA/childB\"\n *  | \"childA/_childB\"\n */\nexport type ExtractPathSuggestions<\n  T extends RouteNodeMap,\n  IsTemplate = false,\n  IsAbsolute = true\n> = {\n  // K = NodeName\n  [K in keyof T]: K extends string // filters out symbol and number\n    ? T[K][\"children\"] extends object // has children\n      ?\n          | K\n          | `${K}/${ExtractPathSuggestions<T[K][\"children\"], IsTemplate>}`\n          | If<\n              IsAbsolute,\n              `${K}/_${ExtractPathSuggestions<\n                T[K][\"children\"],\n                IsTemplate,\n                false\n              >}`\n            >\n      : T[K][\"template\"] extends string\n      ? If<IsTemplate, K>\n      : K\n    : never;\n}[keyof T];\n\n/**\n * PathToParamRecordMap<\n *  \"segement/segment/segment\",\n *  {segment: {..., children: {segment: {..., children: {segment}}}}},\n *  {path: {...}, query: {...}}\n * > => { param: type, ...}\n */\nexport type PathToParamRecordMap<\n  Path extends string,\n  Route extends RouteNodeMap,\n  Params extends ParamRecordMap = ParamRecordMap\n> = Path extends `_${infer Segment}/${infer Rest}` // partial route segment (drop all previous options)\n  ? PathToParamRecordMap<\n      Rest,\n      Route[Segment][\"children\"] & {}, // shortcut to exclude undefined\n      RouteNodeToParamRecordMap<Route[Segment]>\n    >\n  : Path extends `${infer Segment}/${infer Rest}` // regular segment (concat options)\n  ? PathToParamRecordMap<\n      Rest,\n      Route[Segment][\"children\"] & {}, // shortcut to exclude undefined\n      Params & RouteNodeToParamRecordMap<Route[Segment]>\n    >\n  : Path extends `_${infer Segment}` // partial route in the final segment (drop previous options and discontinue)\n  ? RouteNodeToParamRecordMap<Route[Segment]>\n  : Params & RouteNodeToParamRecordMap<Route[Path]>;\n\n/**\n * ExtractRouteNodeMapByPath<\n *  \"segement/segment\",\n *  {segment: {..., children: {segment: {..., children: {segment: { ... }}}}}},\n * > => {segment: { ... }},\n */\nexport type ExtractRouteNodeMapByPath<\n  Path extends string,\n  Route extends RouteNodeMap\n> = Path extends `_${infer Segment}/${infer Rest}` // partial route segment (drop all previous options)\n  ? ExtractRouteNodeMapByPath<\n      Rest,\n      Route[Segment][\"children\"] & {} // shortcut to exclude undefined\n    >\n  : Path extends `${infer Segment}/${infer Rest}` // regular segment (concat options)\n  ? ExtractRouteNodeMapByPath<\n      Rest,\n      Route[Segment][\"children\"] & {} // shortcut to exclude undefined\n    >\n  : Path extends `_${infer Segment}` // partial route in the final segment (drop previous options and discontinue)\n  ? Route[Segment][\"children\"] & {}\n  : Route[Path][\"children\"] & {};\n\nexport type RoutesContext<Routes extends RouteNodeMap> = {\n  template: (path: ExtractPathSuggestions<Routes, true>) => string;\n  render: <Path extends ExtractPathSuggestions<Routes>>(\n    ...args:\n      | [\n          path: Path,\n          params: A.Compute<\n            ExcludeEmptyProperties<PathToParamRecordMap<Path, Routes>>\n          >\n        ]\n      | []\n  ) => string;\n  parseParams: <Path extends ExtractPathSuggestions<Routes>>(\n    path: Path,\n    params: Record<string, any>\n  ) => PathToParamRecordMap<Path, Routes>[\"path\"];\n  parseQuery: <Path extends ExtractPathSuggestions<Routes>>(\n    path: Path,\n    params: Record<string, any>\n  ) => PathToParamRecordMap<Path, Routes>[\"query\"];\n  bind: <Path extends ExtractPathSuggestions<Routes>>(\n    path: Path,\n    params: A.Compute<\n      ExcludeEmptyProperties<PathToParamRecordMap<Path, Routes>>\n    >\n  ) => RoutesContext<ExtractRouteNodeMapByPath<Path, Routes>>;\n  from: <Path extends ExtractPathSuggestions<Routes>>(\n    path: Path,\n    location: string,\n    params: A.Compute<\n      ExcludeEmptyProperties<{\n        path: Partial<PathToParamRecordMap<Path, Routes>[\"path\"]>;\n        query: Partial<PathToParamRecordMap<Path, Routes>[\"query\"]>;\n      }>\n    >\n  ) => RoutesContext<ExtractRouteNodeMapByPath<Path, Routes>>;\n  replace: <Path extends ExtractPathSuggestions<Routes>>(\n    path: Path,\n    location: string,\n    params: A.Compute<\n      ExcludeEmptyProperties<{\n        path: Partial<PathToParamRecordMap<Path, Routes>[\"path\"]>;\n        query: Partial<PathToParamRecordMap<Path, Routes>[\"query\"]>;\n      }>\n    >\n  ) => string;\n};\n\nexport type CreateRoutes = <Routes extends RouteNodeMap>(\n  routes: Routes,\n  renderer?: Renderer,\n  prevCtx?: RenderContext,\n  prevParams?: ParamRecordMap<any>\n) => RoutesContext<Routes>;\n","import {\n  AnyParam,\n  CreateRoutes,\n  ParamRecordMap,\n  RenderContext,\n  RouteNodeMap,\n  RoutesContext,\n  defaultRenderer,\n  str,\n} from \".\";\n\nexport const createRoutes: CreateRoutes = (\n  routeMap,\n  renderer = defaultRenderer,\n  prevSegments,\n  prevParams = { path: {}, query: {} }\n) => {\n  const template = (path: string) => {\n    const ctx = compilePath(routeMap, path);\n    return renderer.template(ctx);\n  };\n\n  const render = (\n    path?: string,\n    params?: ParamRecordMap<any>,\n    context?: RenderContext\n  ) => {\n    const ctx = context ?? compilePath(routeMap, path, prevSegments);\n\n    return renderer.render(ctx, mergeParams(prevParams, params));\n  };\n\n  const bind = (path: string, params: ParamRecordMap<any>) => {\n    const ctx = compilePath(routeMap, path, prevSegments);\n\n    const currSegmentChildren = ctx.nodes[ctx.nodes.length - 1].children ?? {};\n\n    return createRoutes(\n      currSegmentChildren,\n      renderer,\n      ctx,\n      mergeParams(prevParams, params)\n    );\n  };\n\n  const parseParams = (\n    path: string,\n    params: Record<string, string>, // todo: | string,\n    maybeContext?: RenderContext\n  ) => {\n    const parsedParams: Record<string, any> = {};\n    const ctx = maybeContext ?? compilePath(routeMap, path);\n\n    ctx.path.forEach((segment) => {\n      if (typeof segment === \"string\") {\n        return;\n      }\n      if (params[segment.name]) {\n        parsedParams[segment.name] = segment.parser.parse(params[segment.name]);\n      } else if (segment.kind === \"required\") {\n        throw Error(\n          `required path parameter \"${segment.name}\" was not provided for \"${path}\"`\n        );\n      }\n    });\n\n    return parsedParams;\n  };\n\n  const parseQuery = (\n    path: string,\n    params: Record<string, string> | string,\n    maybeContext?: RenderContext\n  ) => {\n    const parsedParams: Record<string, any> = {};\n    const ctx = maybeContext ?? compilePath(routeMap, path);\n\n    const paramsRecord =\n      typeof params === \"string\"\n        ? Object.fromEntries(new URLSearchParams(params))\n        : params;\n\n    ctx.query.forEach((segment) => {\n      if (paramsRecord[segment.name]) {\n        parsedParams[segment.name] = segment.parser.parse(\n          paramsRecord[segment.name]\n        );\n      } else if (segment.kind === \"required\") {\n        throw Error(\n          `required path parameter \"${segment.name}\" was not provided for \"${path}\"`\n        );\n      }\n    });\n\n    return parsedParams;\n  };\n\n  const from = (\n    path: string,\n    location: string,\n    overwriteParams: ParamRecordMap<Record<string, any>>\n  ) => {\n    // build context from path\n    const ctx = compilePath(routeMap, path);\n\n    const lastNodeChildren = ctx.nodes[ctx.nodes.length - 1].children ?? {};\n\n    const { parsedParams } = matchLocation(\n      path,\n      location,\n      ctx,\n      parseParams,\n      parseQuery\n    );\n\n    return createRoutes(\n      lastNodeChildren,\n      renderer,\n      ctx,\n      mergeParams(prevParams, parsedParams, overwriteParams)\n    );\n  };\n\n  const replace = (\n    path: string,\n    location: string,\n    overwriteParams: ParamRecordMap<Record<string, any>>\n  ) => {\n    // basically the same as the from method but returns rendered path with remaining segments appended\n    // appends query string as well (if available)\n\n    const ctx = compilePath(routeMap, path);\n\n    const { parsedParams, tail } = matchLocation(\n      path,\n      location,\n      ctx,\n      parseParams,\n      parseQuery\n    );\n\n    const ctxWithTail = {\n      ...ctx,\n      path: ctx.path.concat(tail.path),\n      query: ctx.query.concat(tail.query), // todo add query params\n    };\n\n    return render(\n      path,\n      mergeParams(prevParams, parsedParams, overwriteParams),\n      ctxWithTail\n    );\n  };\n\n  return {\n    template,\n    bind,\n    render,\n    parseParams,\n    parseQuery,\n    from,\n    replace,\n  } as RoutesContext<any>;\n};\n\nconst compilePath = (\n  routeMap: RouteNodeMap,\n  path?: string,\n  parentCtx?: RenderContext\n): RenderContext => {\n  const ctx: RenderContext = parentCtx ?? {\n    skippedNodes: [],\n    nodes: [],\n    path: [],\n    query: [],\n    isRelative: false,\n  };\n\n  if (!path) {\n    return ctx;\n  }\n\n  const [absolutePath, relativePath] = path.split(\"/_\");\n  const isRelative = typeof relativePath === \"string\";\n\n  if (isRelative) {\n    ctx.skippedNodes = ctx.skippedNodes.concat(ctx.nodes);\n    ctx.nodes = [];\n    ctx.path = [];\n    ctx.query = [];\n    ctx.isRelative = true;\n  }\n\n  let nextNodeMap: RouteNodeMap | undefined = routeMap;\n\n  // skip leading segments in relative path\n  if (isRelative) {\n    absolutePath.split(\"/\").forEach((nodeName) => {\n      if (!nextNodeMap?.[nodeName]) {\n        throw Error(`unknown path segment \"${nodeName}\" in ${path}`);\n      }\n      ctx.skippedNodes.push(nextNodeMap);\n      nextNodeMap = nextNodeMap[nodeName].children;\n    });\n  }\n\n  (relativePath ?? absolutePath).split(\"/\").forEach((nodeName, i) => {\n    if (!nextNodeMap) {\n      throw Error(`unknown segment ${nodeName}`);\n    }\n\n    const nextNode = nextNodeMap[nodeName];\n    ctx.nodes.push(nextNode);\n    ctx.path.push(\n      ...(nextNode.path ?? (nextNode.template ? [nextNode.template] : []))\n    );\n    ctx.query.push(...(nextNode.query ?? []));\n    nextNodeMap = nextNode.children;\n  });\n\n  // extract  path segments and query params and determine if path is relative\n  return ctx;\n};\n\nconst matchLocation = (\n  path: string,\n  location: string,\n  ctx: RenderContext,\n  parseParams: (\n    path: string,\n    params: Record<string, string>,\n    maybeContext?: RenderContext\n  ) => Record<string, string>,\n  parseQuery: (\n    path: string,\n    params: Record<string, string>,\n    maybeContext?: RenderContext\n  ) => Record<string, string>\n) => {\n  const [pathname, queryString] = location.split(\"?\");\n\n  const remainingPathSegments = pathname\n    .slice(pathname[0] === \"/\" ? 1 : 0)\n    .split(\"/\");\n\n  const rawPathParams: Record<string, any> = {};\n\n  // keep track of recent optional params since they might contain path segments\n  // if a path segment doesn't match the algorithm continues searching in this array\n  const recentOptionalParams: string[] = [];\n\n  ctx.path.forEach((segment) => {\n    const pathnameSegment = remainingPathSegments.shift();\n\n    if (typeof segment === \"string\") {\n      if (segment === pathnameSegment) {\n        recentOptionalParams.length = 0; // irrelevant from here\n      } else {\n        // segment might have been swallowed by an optional param\n        let recentParam: string | undefined;\n        let foundMatch = false;\n        while ((recentParam = recentOptionalParams.shift())) {\n          if (rawPathParams[recentParam] === segment) {\n            delete rawPathParams[recentParam];\n            // hold segment back for the next iteration\n            pathnameSegment && remainingPathSegments.unshift(pathnameSegment);\n            foundMatch = true;\n          }\n        }\n        if (!foundMatch) {\n          throw new Error(\n            `\"${pathname}\" doesn't match \"${defaultRenderer.template(\n              ctx\n            )}\", missing segment \"${segment}\"`\n          );\n        }\n      }\n    } else {\n      rawPathParams[segment.name] = pathnameSegment;\n      if (segment.kind === \"optional\") {\n        recentOptionalParams.push(segment.name);\n      } else if (!pathnameSegment) {\n        throw new Error(\n          `\"${pathname}\" doesn't match \"${defaultRenderer.template(\n            ctx\n          )}\", missing parameter \"${segment.name}\"`\n        );\n      } else {\n        recentOptionalParams.length = 0;\n      }\n    }\n  });\n  const rawQueryParams = Object.fromEntries(new URLSearchParams(queryString));\n\n  const parsedParams: ParamRecordMap<Record<string, any>> = {\n    path: parseParams(path, rawPathParams, ctx),\n    query: parseQuery(path, rawQueryParams, ctx),\n  };\n\n  // contains all the remaining path segments and query params\n  const tail: {\n    path: string[];\n    query: AnyParam[];\n  } = {\n    path: remainingPathSegments,\n    query: Object.entries(rawQueryParams).flatMap(([name, value]) => {\n      if (!parsedParams.query[name]) {\n        parsedParams.query[name] = value;\n        return str(name).optional; // context requires a parser, string parser is just the identity function\n      }\n      return [];\n    }),\n  };\n\n  return {\n    parsedParams,\n    tail,\n  };\n};\n\nconst mergeParams = (\n  ...args: (ParamRecordMap<Record<string, any>> | undefined)[]\n): ParamRecordMap<Record<string, any>> => {\n  const result: ParamRecordMap<Record<string, any>> = {\n    path: {},\n    query: {},\n  };\n\n  args.forEach((next) => {\n    result.path = { ...result.path, ...next?.path };\n    result.query = { ...result.query, ...next?.query };\n  });\n\n  return result;\n};\n","import type { ParamRecordMap, RouteNode } from \"./routes\";\n\nexport type RenderContext = {\n  skippedNodes: RouteNode[];\n  nodes: RouteNode[];\n  path: Exclude<RouteNode[\"path\"], undefined>;\n  query: Exclude<RouteNode[\"query\"], undefined>;\n  isRelative: boolean;\n};\n\nexport type Renderer = {\n  template: (ctx: RenderContext) => string;\n  render: (\n    segments: RenderContext,\n    params: ParamRecordMap<Record<string, unknown>>\n  ) => string;\n};\n\nexport const defaultRenderer: Renderer = {\n  template: ({ path, isRelative }) => {\n    const template = path\n      .map((pathSegment) =>\n        typeof pathSegment === \"string\"\n          ? pathSegment\n          : `:${pathSegment.name}${pathSegment.kind === \"optional\" ? \"?\" : \"\"}`\n      )\n      .join(\"/\");\n\n    return isRelative\n      ? template //relative\n      : `/${template}`; // absolute\n  },\n  render: ({ path, query, isRelative }, params) => {\n    const pathSegments: string[] = [];\n    const queryRecord: Record<string, string> = {};\n\n    // path params\n    path.forEach((pathSegment) => {\n      if (typeof pathSegment === \"string\") {\n        pathSegments.push(pathSegment);\n      } else if (\n        pathSegment.kind === \"required\" &&\n        !params.path[pathSegment.name]\n      ) {\n        throw Error(\n          `required path parameter ${pathSegment.name} was not specified`\n        );\n      } else if (params.path[pathSegment.name]) {\n        pathSegments.push(\n          pathSegment.parser.serialize(params.path[pathSegment.name])\n        );\n      }\n    });\n\n    // query params\n    query.forEach((queryParam) => {\n      if (queryParam.kind === \"required\" && !params.query[queryParam.name]) {\n        throw Error(\n          `required query parameter ${queryParam.name} was not specified`\n        );\n      }\n      if (params.query[queryParam.name]) {\n        queryRecord[queryParam.name] = queryParam.parser.serialize(\n          params.query[queryParam.name]\n        );\n      }\n    });\n\n    const searchParams = new URLSearchParams(queryRecord).toString();\n\n    return (\n      (isRelative ? \"\" : \"/\") +\n      pathSegments.join(\"/\") +\n      (searchParams ? `?` : \"\") +\n      searchParams\n    );\n  },\n};\n"],"names":[],"version":3,"file":"index.cjs.map","sourceRoot":"../"}