{"mappings":"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","sources":["src/index.ts","src/param.ts","src/routes.ts","src/createRoutes.ts","src/renderer.ts"],"sourcesContent":["export * from \"./param\";\nexport * from \"./routes\";\nexport * from \"./createRoutes\";\nexport * from \"./renderer\";\n","export type ParamKind = \"optional\" | \"required\";\n\nexport type AnyParam = Param<string, any, any>;\n\nexport type Param<N = string, T = any, K extends ParamKind = \"required\"> = {\n  name: N;\n  kind: K;\n  parser: Parser<T>;\n  value?: string;\n} & (K extends \"required\" ? { optional: Param<N, T, \"optional\"> } : {});\n\nexport interface Parser<T> {\n  parse: (value: string) => T;\n  serialize: (value: T) => string;\n}\n\ntype ParamFn = <T>(\n  parser: Parser<T>\n) => <N extends string>(name: N) => Param<N, T, \"required\">;\n\nexport const param: ParamFn = (parser) => (name) => ({\n  name,\n  kind: \"required\",\n  parser,\n  optional: {\n    name,\n    kind: \"optional\",\n    parser,\n  } as Param<any, any, \"optional\">,\n});\n\nexport const int = param({\n  parse: (value: string) => {\n    const result = parseInt(value, 10);\n    if (result !== result) {\n      throw new Error(`parameter value is invalid: \"${result}\"`);\n    }\n    return result;\n  },\n  serialize: (value: number) => value.toString(),\n});\n\nexport const str = param({\n  parse: (value: string) => value,\n  serialize: (value: string) => value,\n});\n\nexport const float = (fractionDigits?: number) =>\n  param({\n    parse: (value: string) => parseFloat(value),\n    serialize: (value: number) => value.toFixed(fractionDigits),\n  });\n\nexport const isoDate = param({\n  parse: (value: string) => new Date(value),\n  serialize: (value: Date) => value.toISOString(),\n});\n\nexport const date = param({\n  parse: (value: string) => new Date(value),\n  serialize: (value: Date) => value.toISOString().slice(0, 10),\n});\n\nexport const bool = param({\n  parse: (value: string) => value === \"true\",\n  serialize: (value: boolean) => value.toString(),\n});\n\nexport const oneOf = (...list: string[]) =>\n  param({\n    parse: (value: string) => {\n      if (!list.includes(value)) {\n        throw new Error(`\"${value}\" is none of ${list.join(\",\")}`);\n      }\n      return value;\n    },\n    serialize: (value: string) => value,\n  });\n\nexport const list = (_: string[], separator = \";\") =>\n  param({\n    parse: (value: string) => value.split(separator),\n    serialize: (options: string[]) => options.join(separator),\n  });\n\nexport const json = <T>() =>\n  param({\n    parse: (value: string) => JSON.parse(value),\n    serialize: (value: T) => JSON.stringify(value),\n  });\n\nexport const base64 = <T>() =>\n  param({\n    parse: (value) => JSON.parse(window.btoa(value)),\n    serialize: (value: T) => window.atob(JSON.stringify(value)),\n  });\n","import type { A } from \"ts-toolbelt\";\nimport type { AnyParam } from \"./param\";\nimport type { RenderContext, Renderer } from \"./renderer\";\n\ntype If<Condition, Then> = Condition extends true ? Then : never;\ntype Unwrap<T> = T extends unknown[] ? T[number] : never;\n\n/**\n * ExcludeEmptyProperties<{\n *  path: {param: string},\n *  query: {}\n * }> => {\n *  path: {param: string},\n *  query: never,\n * }\n */\ntype ExcludeEmptyProperties<T> = Pick<\n  T,\n  {\n    [K in keyof T]: keyof T[K] extends never ? never : K;\n  }[keyof T]\n>;\n\nexport type RouteNode = {\n  path?: (string | AnyParam)[];\n  template?: string;\n  query?: AnyParam[];\n  children?: RouteNodeMap;\n};\nexport type RouteNodeMap = Record<string, RouteNode>;\n\n/**\n * RouteNodeToParamRecordMap<{\n *  path?: (string | AnyParamParam<TName, TValue>)[];\n *  query?: Param<TName, TValue>[];\n *  children?: RouteNodeMap;\n * }> => {\n *  path: {[TName]: TValue, ...},\n *  query: {[TName]: TValue, ...}\n * }\n */\nexport type RouteNodeToParamRecordMap<T extends RouteNode> = {\n  path: ExtractParamRecord<Exclude<Unwrap<T[\"path\"]>, string | undefined>>;\n  query: ExtractParamRecord<Exclude<Unwrap<T[\"query\"]>, undefined>>;\n};\nexport type ParamRecordMap<T = unknown> = Record<\"path\" | \"query\", T>;\n\n/**\n * ExtractParamRecord<{\n *  kind: \"required\" | \"optional\";\n *  name: TName;\n *  parser: Parser<TParseType>\n * } | {...}> => {\n *  [TName]: TParseType,\n *  [TName]?: TParseType,\n *  ...\n * }\n */\nexport type ExtractParamRecord<Params extends AnyParam> = {\n  [K in Extract<Params, { kind: \"required\" }>[\"name\"]]: ReturnType<\n    Extract<Params, { name: K }>[\"parser\"][\"parse\"]\n  >;\n} & {\n  [K in Extract<Params, { kind: \"optional\" }>[\"name\"]]?: ReturnType<\n    Extract<Params, { name: K }>[\"parser\"][\"parse\"]\n  >;\n};\n\n/**\n * ExtractPathSuggestions<{\n *  childA: {\n *    ...,\n *    childrend: {\n *      childB: {\n *        ...\n *      }\n *    }\n *  }\n * }> =>\n *  | \"childA\"\n *  | \"childA/childB\"\n *  | \"childA/_childB\"\n */\nexport type ExtractPathSuggestions<\n  T extends RouteNodeMap,\n  IsTemplate = false,\n  IsAbsolute = true\n> = {\n  // K = NodeName\n  [K in keyof T]: K extends string // filters out symbol and number\n    ? T[K][\"children\"] extends object // has children\n      ?\n          | K\n          | `${K}/${ExtractPathSuggestions<T[K][\"children\"], IsTemplate>}`\n          | If<\n              IsAbsolute,\n              `${K}/_${ExtractPathSuggestions<\n                T[K][\"children\"],\n                IsTemplate,\n                false\n              >}`\n            >\n      : T[K][\"template\"] extends string\n      ? If<IsTemplate, K>\n      : K\n    : never;\n}[keyof T];\n\n/**\n * PathToParamRecordMap<\n *  \"segement/segment/segment\",\n *  {segment: {..., children: {segment: {..., children: {segment}}}}},\n *  {path: {...}, query: {...}}\n * > => { param: type, ...}\n */\nexport type PathToParamRecordMap<\n  Path extends string,\n  Route extends RouteNodeMap,\n  Params extends ParamRecordMap = ParamRecordMap\n> = Path extends `_${infer Segment}/${infer Rest}` // partial route segment (drop all previous options)\n  ? PathToParamRecordMap<\n      Rest,\n      Route[Segment][\"children\"] & {}, // shortcut to exclude undefined\n      RouteNodeToParamRecordMap<Route[Segment]>\n    >\n  : Path extends `${infer Segment}/${infer Rest}` // regular segment (concat options)\n  ? PathToParamRecordMap<\n      Rest,\n      Route[Segment][\"children\"] & {}, // shortcut to exclude undefined\n      Params & RouteNodeToParamRecordMap<Route[Segment]>\n    >\n  : Path extends `_${infer Segment}` // partial route in the final segment (drop previous options and discontinue)\n  ? RouteNodeToParamRecordMap<Route[Segment]>\n  : Params & RouteNodeToParamRecordMap<Route[Path]>;\n\n/**\n * ExtractRouteNodeMapByPath<\n *  \"segement/segment\",\n *  {segment: {..., children: {segment: {..., children: {segment: { ... }}}}}},\n * > => {segment: { ... }},\n */\nexport type ExtractRouteNodeMapByPath<\n  Path extends string,\n  Route extends RouteNodeMap\n> = Path extends `_${infer Segment}/${infer Rest}` // partial route segment (drop all previous options)\n  ? ExtractRouteNodeMapByPath<\n      Rest,\n      Route[Segment][\"children\"] & {} // shortcut to exclude undefined\n    >\n  : Path extends `${infer Segment}/${infer Rest}` // regular segment (concat options)\n  ? ExtractRouteNodeMapByPath<\n      Rest,\n      Route[Segment][\"children\"] & {} // shortcut to exclude undefined\n    >\n  : Path extends `_${infer Segment}` // partial route in the final segment (drop previous options and discontinue)\n  ? Route[Segment][\"children\"] & {}\n  : Route[Path][\"children\"] & {};\n\nexport type RoutesContext<Routes extends RouteNodeMap> = {\n  template: (path: ExtractPathSuggestions<Routes, true>) => string;\n  render: <Path extends ExtractPathSuggestions<Routes>>(\n    ...args:\n      | [\n          path: Path,\n          params: A.Compute<\n            ExcludeEmptyProperties<PathToParamRecordMap<Path, Routes>>\n          >\n        ]\n      | []\n  ) => string;\n  parseParams: <Path extends ExtractPathSuggestions<Routes>>(\n    path: Path,\n    params: Record<string, any>\n  ) => PathToParamRecordMap<Path, Routes>[\"path\"];\n  parseQuery: <Path extends ExtractPathSuggestions<Routes>>(\n    path: Path,\n    params: Record<string, any>\n  ) => PathToParamRecordMap<Path, Routes>[\"query\"];\n  bind: <Path extends ExtractPathSuggestions<Routes>>(\n    path: Path,\n    params: A.Compute<\n      ExcludeEmptyProperties<PathToParamRecordMap<Path, Routes>>\n    >\n  ) => RoutesContext<ExtractRouteNodeMapByPath<Path, Routes>>;\n  from: <Path extends ExtractPathSuggestions<Routes>>(\n    path: Path,\n    location: string,\n    params: A.Compute<\n      ExcludeEmptyProperties<{\n        path: Partial<PathToParamRecordMap<Path, Routes>[\"path\"]>;\n        query: Partial<PathToParamRecordMap<Path, Routes>[\"query\"]>;\n      }>\n    >\n  ) => RoutesContext<ExtractRouteNodeMapByPath<Path, Routes>>;\n  replace: <Path extends ExtractPathSuggestions<Routes>>(\n    path: Path,\n    location: string,\n    params: A.Compute<\n      ExcludeEmptyProperties<{\n        path: Partial<PathToParamRecordMap<Path, Routes>[\"path\"]>;\n        query: Partial<PathToParamRecordMap<Path, Routes>[\"query\"]>;\n      }>\n    >\n  ) => string;\n};\n\nexport type CreateRoutes = <Routes extends RouteNodeMap>(\n  routes: Routes,\n  renderer?: Renderer,\n  prevCtx?: RenderContext,\n  prevParams?: ParamRecordMap<any>\n) => RoutesContext<Routes>;\n","import {\n  CreateRoutes,\n  ParamRecordMap,\n  RouteNode,\n  RouteNodeMap,\n  RoutesContext,\n  defaultRenderer,\n  str,\n} from \".\";\n\nexport type RenderContext = {\n  skippedNodes: RouteNode[]; // containes leading nodes that were skipped in a relative path\n  nodes: RouteNode[];\n  path: Exclude<RouteNode[\"path\"], undefined>;\n  query: Exclude<RouteNode[\"query\"], undefined>;\n  isRelative: boolean;\n  rawParams: Record<string, string>;\n  rawQuery: Record<string, string>;\n  parsedParams: Record<string, unknown>;\n  parsedQuery: Record<string, unknown>;\n};\n\nexport const createRoutes: CreateRoutes = (\n  routeMap,\n  renderer = defaultRenderer,\n  parentContext\n) => {\n  const render = (\n    path?: string,\n    params?: ParamRecordMap<any>,\n    context?: RenderContext\n  ) => {\n    const ctx = pipe(\n      context ?? createRenderContext(routeMap, path, parentContext),\n      withRawParams(params?.path),\n      withRawQuery(params?.query),\n      withParsedParams,\n      withParsedQuery\n    );\n\n    return renderer.render(ctx);\n  };\n\n  const bind = (path: string, params: ParamRecordMap<any>) => {\n    const ctx = pipe(\n      createRenderContext(routeMap, path, parentContext),\n      withRawParams(params.path),\n      withRawQuery(params.query)\n    );\n\n    const pathChildren = ctx.nodes[ctx.nodes.length - 1].children ?? {};\n\n    return createRoutes(pathChildren, renderer, ctx);\n  };\n\n  const template = (path: string) =>\n    renderer.template(createRenderContext(routeMap, path));\n\n  const parseParams = (\n    path: string,\n    params: Record<string, string> | string\n  ) => {\n    const ctx = pipe(\n      createRenderContext(routeMap, path, parentContext),\n      typeof params === \"string\"\n        ? withRawParamsFromLocationPath(params)\n        : withRawParams(params),\n      withParsedParams\n    );\n\n    return ctx.parsedParams;\n  };\n\n  const parseQuery = (path: string, query: Record<string, string> | string) => {\n    const ctx = pipe(\n      createRenderContext(routeMap, path, parentContext),\n      typeof query === \"string\"\n        ? withRawQueryFromUrlSearch(query)\n        : withRawQuery(query),\n      withParsedQuery\n    );\n\n    return ctx.parsedQuery;\n  };\n\n  const from = (\n    path: string,\n    location: string,\n    overrideParams: ParamRecordMap<Record<string, any>>\n  ) => {\n    const [locationPath, locationQuery] = location.split(\"?\");\n    const ctx = pipe(\n      createRenderContext(routeMap, path, parentContext),\n      withRawParamsFromLocationPath(locationPath),\n      withRawQueryFromUrlSearch(locationQuery),\n      withRawParams(overrideParams.path),\n      withRawQuery(overrideParams.query)\n    );\n\n    const pathChildren = ctx.nodes[ctx.nodes.length - 1].children ?? {};\n\n    return createRoutes(pathChildren, renderer, ctx);\n  };\n\n  // basically the same as the from method but returns rendered path with remaining segments appended\n  // appends query string as well (if available)\n  const replace = (\n    path: string,\n    location: string,\n    overrideParams: ParamRecordMap<Record<string, any>>\n  ) => {\n    const [locationPath, locationQuery] = location.split(\"?\");\n    const ctx = pipe(\n      createRenderContext(routeMap, path, parentContext),\n      withRawParamsFromLocationPath(locationPath, true),\n      withRawParams(overrideParams.path),\n      withRawQueryFromUrlSearch(locationQuery, true),\n      withRawQuery(overrideParams.query),\n      withParsedParams,\n      withParsedQuery\n    );\n\n    return renderer.render(ctx);\n  };\n\n  return {\n    render,\n    bind,\n    template,\n    parseParams,\n    parseQuery,\n    from,\n    replace,\n  } as RoutesContext<any>;\n};\n\nconst createRenderContext = (\n  routeMap: RouteNodeMap,\n  path?: string,\n  parentCtx?: RenderContext\n): RenderContext => {\n  let ctx: RenderContext = parentCtx ?? {\n    skippedNodes: [],\n    nodes: [],\n    path: [],\n    query: [],\n    isRelative: false,\n    rawParams: {},\n    rawQuery: {},\n    parsedParams: {},\n    parsedQuery: {},\n  };\n\n  if (!path) {\n    return ctx;\n  }\n\n  const [absolutePath, relativePath] = path.split(\"/_\");\n  const isRelative = typeof relativePath === \"string\";\n\n  if (isRelative) {\n    ctx = {\n      ...ctx,\n      skippedNodes: ctx.skippedNodes.concat(ctx.nodes),\n      nodes: [],\n      path: [],\n      query: [],\n      isRelative: true,\n    };\n  }\n\n  let nextNodeMap: RouteNodeMap | undefined = routeMap;\n\n  // skip leading segments in relative path\n  if (isRelative) {\n    absolutePath.split(\"/\").forEach((nodeName) => {\n      if (!nextNodeMap?.[nodeName]) {\n        throw Error(`unknown path segment \"${nodeName}\" in ${path}`);\n      }\n      ctx.skippedNodes.push(nextNodeMap[nodeName]);\n      nextNodeMap = nextNodeMap[nodeName].children;\n    });\n  }\n\n  (relativePath ?? absolutePath).split(\"/\").forEach((nodeName, i) => {\n    if (!nextNodeMap) {\n      throw Error(`unknown segment ${nodeName}`);\n    }\n\n    const nextNode = nextNodeMap[nodeName];\n    ctx.nodes.push(nextNode);\n    ctx.path.push(\n      ...(nextNode.path ?? (nextNode.template ? [nextNode.template] : []))\n    );\n    ctx.query.push(...(nextNode.query ?? []));\n    nextNodeMap = nextNode.children;\n  });\n\n  return ctx;\n};\n\nconst withRawParamsFromLocationPath =\n  (locationPath: string = \"\", includeExtraPath: boolean = false) =>\n  (ctx: RenderContext): RenderContext => {\n    const remaining = locationPath\n      .slice(locationPath[0] === \"/\" ? 1 : 0)\n      .split(\"/\");\n\n    const rawParams: Record<string, any> = {};\n\n    // keep track of recent optional params since they might contain path segments\n    // if a path segment doesn't match the algorithm continues searching in this array\n    const recentOptionalParams: string[] = [];\n\n    ctx.path.forEach((segment) => {\n      const locationPathSegment = remaining.shift();\n\n      if (typeof segment === \"string\") {\n        if (segment === locationPathSegment) {\n          recentOptionalParams.length = 0; // irrelevant from here\n        } else {\n          // segment might have been swallowed by an optional param\n          let recentParam: string | undefined;\n          let foundMatch = false;\n          while ((recentParam = recentOptionalParams.shift())) {\n            if (rawParams[recentParam] === segment) {\n              delete rawParams[recentParam];\n              // hold segment back for the next iteration\n              locationPathSegment && remaining.unshift(locationPathSegment);\n              foundMatch = true;\n            }\n          }\n          if (!foundMatch) {\n            throw new Error(\n              `\"${locationPath}\" doesn't match \"${defaultRenderer.template(\n                ctx\n              )}\", missing segment \"${segment}\"`\n            );\n          }\n        }\n      } else {\n        rawParams[segment.name] = locationPathSegment;\n        if (segment.kind === \"optional\") {\n          recentOptionalParams.push(segment.name);\n        } else if (!locationPathSegment) {\n          throw new Error(\n            `\"${locationPath}\" doesn't match \"${defaultRenderer.template(\n              ctx\n            )}\", missing parameter \"${segment.name}\"`\n          );\n        } else {\n          recentOptionalParams.length = 0;\n        }\n      }\n    });\n\n    return {\n      ...ctx,\n      rawParams,\n      path: includeExtraPath ? ctx.path.concat(remaining) : ctx.path,\n    };\n  };\n\nconst withRawParams =\n  (rawParams?: Record<string, string>) =>\n  (ctx: RenderContext): RenderContext => ({\n    ...ctx,\n    rawParams: { ...ctx.rawParams, ...rawParams },\n  });\n\nconst withParsedParams = (ctx: RenderContext): RenderContext => {\n  const parsedParams: Record<string, any> = {};\n\n  ctx.path.forEach((segment) => {\n    if (typeof segment === \"string\") {\n      return;\n    }\n    if (ctx.rawParams[segment.name]) {\n      parsedParams[segment.name] = segment.parser.parse(\n        ctx.rawParams[segment.name]\n      );\n    } else if (segment.kind === \"required\") {\n      throw Error(\n        `required path parameter \"${\n          segment.name\n        }\" was not provided in \"${defaultRenderer.template(ctx)}\"`\n      );\n    }\n  });\n\n  return {\n    ...ctx,\n    parsedParams,\n  };\n};\n\nconst withRawQueryFromUrlSearch =\n  (urlSearchParams: string = \"\", includeExtraQuery: boolean = false) =>\n  (ctx: RenderContext): RenderContext => ({\n    ...ctx,\n    ...withRawQuery(\n      Object.fromEntries(new URLSearchParams(urlSearchParams)),\n      includeExtraQuery\n    )(ctx),\n  });\n\nconst withRawQuery =\n  (queryParams?: Record<string, string>, includeExtraQuery: boolean = false) =>\n  (ctx: RenderContext): RenderContext => {\n    const remaining = { ...queryParams };\n    const rawQuery: Record<string, string> = {};\n\n    ctx.query.forEach(({ name }) => {\n      if (name in remaining) {\n        rawQuery[name] = remaining[name];\n        delete remaining[name];\n      }\n    });\n\n    return {\n      ...ctx,\n      rawQuery: {\n        ...ctx.rawQuery,\n        ...rawQuery,\n        ...(includeExtraQuery ? remaining : undefined),\n      },\n      query: includeExtraQuery\n        ? ctx.query.concat(\n            Object.keys(remaining).map((name) => str(name).optional)\n          )\n        : ctx.query,\n    };\n  };\n\nconst withParsedQuery = (ctx: RenderContext): RenderContext => {\n  const parsedQuery: Record<string, any> = {};\n\n  ctx.query.forEach((segment) => {\n    if (ctx.rawQuery[segment.name]) {\n      parsedQuery[segment.name] = segment.parser.parse(\n        ctx.rawQuery[segment.name]\n      );\n    } else if (segment.kind === \"required\") {\n      throw Error(\n        `required query parameter \"${\n          segment.name\n        }\" was not provided in \"${defaultRenderer.template(ctx)}\"`\n      );\n    }\n  });\n\n  return {\n    ...ctx,\n    parsedQuery: { ...ctx.parsedQuery, ...parsedQuery },\n  };\n};\n\nconst pipe = (\n  initialCtx: RenderContext,\n  ...fns: ((ctx: RenderContext) => RenderContext)[]\n) => fns.reduce((ctx, fn) => fn(ctx), initialCtx);\n","import type { ParamRecordMap, RouteNode } from \"./routes\";\n\nexport type RenderContext = {\n  skippedNodes: RouteNode[];\n  nodes: RouteNode[];\n  path: Exclude<RouteNode[\"path\"], undefined>;\n  query: Exclude<RouteNode[\"query\"], undefined>;\n  isRelative: boolean;\n};\n\nexport type Renderer = {\n  template: (ctx: RenderContext) => string;\n  render: (\n    segments: RenderContext,\n    params: ParamRecordMap<Record<string, unknown>>\n  ) => string;\n};\n\nexport const defaultRenderer: Renderer = {\n  template: ({ path, isRelative }) => {\n    const template = path\n      .map((pathSegment) =>\n        typeof pathSegment === \"string\"\n          ? pathSegment\n          : `:${pathSegment.name}${pathSegment.kind === \"optional\" ? \"?\" : \"\"}`\n      )\n      .join(\"/\");\n\n    return isRelative\n      ? template //relative\n      : `/${template}`; // absolute\n  },\n  render: ({ path, query, isRelative }, params) => {\n    const pathSegments: string[] = [];\n    const queryRecord: Record<string, string> = {};\n\n    // path params\n    path.forEach((pathSegment) => {\n      if (typeof pathSegment === \"string\") {\n        pathSegments.push(pathSegment);\n      } else if (\n        pathSegment.kind === \"required\" &&\n        !params.path[pathSegment.name]\n      ) {\n        throw Error(\n          `required path parameter ${pathSegment.name} was not specified`\n        );\n      } else if (params.path[pathSegment.name]) {\n        pathSegments.push(\n          pathSegment.parser.serialize(params.path[pathSegment.name])\n        );\n      }\n    });\n\n    // query params\n    query.forEach((queryParam) => {\n      if (queryParam.kind === \"required\" && !params.query[queryParam.name]) {\n        throw Error(\n          `required query parameter ${queryParam.name} was not specified`\n        );\n      }\n      if (params.query[queryParam.name]) {\n        queryRecord[queryParam.name] = queryParam.parser.serialize(\n          params.query[queryParam.name]\n        );\n      }\n    });\n\n    const searchParams = new URLSearchParams(queryRecord).toString();\n\n    return (\n      (isRelative ? \"\" : \"/\") +\n      pathSegments.join(\"/\") +\n      (searchParams ? `?` : \"\") +\n      searchParams\n    );\n  },\n};\n"],"names":[],"version":3,"file":"index.cjs.map","sourceRoot":"../"}